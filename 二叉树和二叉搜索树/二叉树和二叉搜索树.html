<!DOCTYPE html>
<html lang="zh-Hans-CN"><head><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=Edge"/><link rel="stylesheet" type="text/css" href="../css/modern-norm.min.css"/><link rel="stylesheet" type="text/css" href="../css/prism.min.css"/><link rel="stylesheet" type="text/css" href="../css/katex.min.css"/><link rel="stylesheet" type="text/css" href="../css/wolai.css"/><title>二叉树和二叉搜索树 - wolai 笔记</title><link rel="shortcut icon" href="data:image/svg+xml,%3Csvg xmlns=&apos;http://www.w3.org/2000/svg&apos; viewBox=&apos;0 0 800 800&apos;%3E%3Cdefs%3E%3Cstyle%3E.cls-1%7Bfill:%23fff;%7D%3C/style%3E%3C/defs%3E%3Cg%3E%3Cpath class=&apos;cls-1&apos; d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Z&apos;/%3E%3Cpath d=&apos;M610.08,0c66,0,90,6.88,114.13,19.79a134.62,134.62,0,0,1,56,56l2.28,4.4C793.93,103,800,127.88,800,189.92V610.08l-.08,11.56c-.78,57.38-7.58,79.89-19.71,102.57a134.62,134.62,0,0,1-56,56l-4.4,2.28C697,793.93,672.12,800,610.08,800H189.92l-11.56-.08c-57.38-.78-79.89-7.58-102.57-19.71a134.62,134.62,0,0,1-56-56l-2.28-4.4C6.44,697.75.4,673.72,0,616L0,189.92c0-66,6.88-90,19.79-114.13a134.62,134.62,0,0,1,56-56l4.4-2.28C102.25,6.44,126.28.4,184,0Zm4.72,88.9H185.2L172.42,89c-32.78.62-43.68,3.24-54.71,9.14a45.84,45.84,0,0,0-19.54,19.54c-6.61,12.36-9.11,24.55-9.27,67.49V614.8L89,627.58c.62,32.78,3.24,43.68,9.14,54.71a45.84,45.84,0,0,0,19.54,19.54c12.36,6.61,24.55,9.11,67.49,9.27H610.08c46.79,0,59.41-2.44,72.21-9.28a45.84,45.84,0,0,0,19.54-19.54c6.61-12.36,9.11-24.55,9.27-67.49V189.92c0-46.79-2.44-59.41-9.28-72.21a45.84,45.84,0,0,0-19.54-19.54C669.93,91.56,657.74,89.06,614.8,88.9ZM233.33,493.33A73.34,73.34,0,1,1,160,566.67,73.35,73.35,0,0,1,233.33,493.33Z&apos;/%3E%3C/g%3E%3C/svg%3E"></link></head><body><header><div class="image"></div><div class="title"><div class="banner"><div class="icon"></div></div><div data-title="二叉树和二叉搜索树" class="main-title"></div></div></header><article><div id="t1sVqCbqsgUFWbsEWADHcF" class="wolai-block wolai-text"><div><span class="inline-wrap">二叉树和二叉搜索树是非常重要的数据结构，在面试中也经常会被考察。我们先了解二叉树和二叉搜索树的基本概念，然后通过一些示例题目来加深理解。</span></div></div><h3 id="5oward5i1j1eAN7mbbGjk3" class="wolai-block"><span class="inline-wrap">二叉树 (Binary Tree)</span></h3><h4 id="35KLXoz3U1SieTWmV13bPV" class="wolai-block"><span class="inline-wrap">基本概念</span></h4><ul class="wolai-block"><li id="57UjNteE7h9end76R7tKmQ"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>节点 (Node)</b></span><span class="inline-wrap">：二叉树的基本单元，每个节点最多有两个子节点。</span></li><li id="vwEs3wanqAdM7LXDjxKGsK"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>根节点 (Root)</b></span><span class="inline-wrap">：树的顶端节点。</span></li><li id="tXnmNCmHCrnJkRBMAJdDLV"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>叶节点 (Leaf)</b></span><span class="inline-wrap">：没有子节点的节点。</span></li><li id="uFAKY8HN1yYZ3ToTeyV8Gr"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap"><b>高度 (Height)</b></span><span class="inline-wrap">：从根节点到叶节点的最长路径。</span></li></ul><h4 id="53agpZpE17kVLxv44qNDXP" class="wolai-block"><span class="inline-wrap">基本操作</span></h4><ol class="wolai-block"><li id="2gbRTBLR5T7ibsqHhrkXia"><div class="marker"></div><span class="inline-wrap"><b>前序遍历 (Pre-order Traversal)</b></span><span class="inline-wrap">：根节点 -&gt; 左子树 -&gt; 右子树</span></li><li id="8aKc4uR3FbNSK3NejoNm2C"><div class="marker"></div><span class="inline-wrap"><b>中序遍历 (In-order Traversal)</b></span><span class="inline-wrap">：左子树 -&gt; 根节点 -&gt; 右子树</span></li><li id="bGY5t3J2n8htmxLpFukrAz"><div class="marker"></div><span class="inline-wrap"><b>后序遍历 (Post-order Traversal)</b></span><span class="inline-wrap">：左子树 -&gt; 右子树 -&gt; 根节点</span></li></ol><h3 id="577uSLWhXqijxDUTd4w5rm" class="wolai-block"><span class="inline-wrap">二叉搜索树 (Binary Search Tree, BST)</span></h3><h4 id="4gWk9JPTVwAJq8BqTZbUPt" class="wolai-block"><span class="inline-wrap">特性</span></h4><ul class="wolai-block"><li id="vATaBYZJqRBGGpMnCcsxCd"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">左子树上所有节点的值均小于根节点的值。</span></li><li id="hrGfupy79zDPxJQzrZrpTq"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">右子树上所有节点的值均大于根节点的值。</span></li><li id="n8LepeYwVNvvstkiH8WK4m"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">左右子树也分别为二叉搜索树。</span></li></ul><h3 id="hEMjbqCNDzzNdNPe4ifUD5" class="wolai-block"><span class="inline-wrap">示例代码</span></h3><code-block id="aem1FQbe3ny4iTJqz1qQWa" class="wolai-block"><div class="wolai-pre"><div data-lang="Python" class="marker"></div><pre><span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> val<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> left<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">,</span> right<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>val <span class="token operator">=</span> val
        self<span class="token punctuation">.</span>left <span class="token operator">=</span> left
        self<span class="token punctuation">.</span>right <span class="token operator">=</span> right</pre></div></code-block><h3 id="wUcDvM2ePv2Dr4tAU55Ws" class="wolai-block"><span class="inline-wrap">示例题目 1：二叉树的最大深度 (Maximum Depth of Binary Tree)</span></h3><h4 id="tLfL5ZZMbKbdarEXZfFHxv" class="wolai-block"><span class="inline-wrap">题目描述</span></h4><ul class="wolai-block"><li id="6NrJ9uMhaUKFddPG3rVX18"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">题目： 给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</span><div id="o74MxQaS3ayvs8CtuuTwcX" class="wolai-block wolai-text"><div><span class="inline-wrap">示例：</span></div></div><code-block id="51UjwAhoy4Wt1ZmMjXHMxm" class="wolai-block"><div class="wolai-pre"><div data-lang="TypeScript" class="marker"></div><pre>输入<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">]</span>
输出<span class="token operator">:</span> <span class="token number">3</span></pre></div></code-block></li></ul><h4 id="6CgRUALFFfg2heJzyCm2iM" class="wolai-block"><span class="inline-wrap">解答</span></h4><div id="rRWp7T7faG9zmfs9xEsmSw" class="wolai-block wolai-text"><div><span class="inline-wrap">我们可以使用递归的方式来解决这个问题，通过遍历每个节点，计算其左右子树的最大深度，并返回其中较大者加一。</span></div></div><code-block id="maRy74ea9r2Bt23QdcavNz" class="wolai-block"><div class="wolai-pre"><div data-lang="Python" class="marker"></div><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">maxDepth</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">int</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token number">0</span>
        left_depth <span class="token operator">=</span> self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span>
        right_depth <span class="token operator">=</span> self<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token builtin">max</span><span class="token punctuation">(</span>left_depth<span class="token punctuation">,</span> right_depth<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>

<span class="token comment"># 测试样例</span>
root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> TreeNode<span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">,</span> TreeNode<span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">,</span> TreeNode<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">,</span> TreeNode<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>solution<span class="token punctuation">.</span>maxDepth<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出: 3</span></pre></div></code-block><h3 id="oVUXQdzxuhhEax5xeUY8kz" class="wolai-block"><span class="inline-wrap">示例题目 2：验证二叉搜索树 (Validate Binary Search Tree)</span></h3><h4 id="3QgZEQZKpMJP1vTWa33RCN" class="wolai-block"><span class="inline-wrap">题目描述</span></h4><ul class="wolai-block"><li id="499bH3cNK7ebAn46PD4R6c"><div class="marker"><svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M12 14.5a2.5 2.5 0 100-5 2.5 2.5 0 000 5z"></path></svg></div><span class="inline-wrap">题目： 给定一个二叉树，判断其是否是一个有效的二叉搜索树。</span><div id="kLqj2j3Gk3fHeJkJdvb4Mt" class="wolai-block wolai-text"><div><span class="inline-wrap">示例：</span></div></div><code-block id="dCvxA1YXVBZ91jPnRRAKU4" class="wolai-block"><div class="wolai-pre"><div data-lang="TypeScript" class="marker"></div><pre>输入<span class="token operator">:</span>
    <span class="token number">2</span>
   <span class="token operator">/</span> \
  <span class="token number">1</span>   <span class="token number">3</span>
输出<span class="token operator">:</span> True</pre></div></code-block></li></ul><h4 id="9C71RWcJnicejYL589Mo7J" class="wolai-block"><span class="inline-wrap">解答</span></h4><div id="5gb8nQpJkG3HWm9eLVyDVR" class="wolai-block wolai-text"><div><span class="inline-wrap">我们可以使用递归来验证二叉搜索树，通过传递当前节点的值范围来检查每个节点是否满足 BST 的特性。</span></div></div><code-block id="xgWqKsw7AQVn4r8CzFrVVS" class="wolai-block"><div class="wolai-pre"><div data-lang="Python" class="marker"></div><pre><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">isValidBST</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">,</span> lower<span class="token operator">=</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'-inf'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> upper<span class="token operator">=</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token string">'inf'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">bool</span><span class="token punctuation">:</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> root<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">True</span>
        val <span class="token operator">=</span> root<span class="token punctuation">.</span>val
        <span class="token keyword">if</span> val <span class="token operator">&lt;=</span> lower <span class="token keyword">or</span> val <span class="token operator">>=</span> upper<span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>isValidBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">,</span> val<span class="token punctuation">,</span> upper<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> self<span class="token punctuation">.</span>isValidBST<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">,</span> lower<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">:</span>
            <span class="token keyword">return</span> <span class="token boolean">False</span>
        <span class="token keyword">return</span> <span class="token boolean">True</span>

<span class="token comment"># 测试样例</span>
root <span class="token operator">=</span> TreeNode<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> TreeNode<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> TreeNode<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
solution <span class="token operator">=</span> Solution<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span>solution<span class="token punctuation">.</span>isValidBST<span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 输出: True</span></pre></div></code-block><h3 id="tgyovQZsJvEmHb1rmi6QDy" class="wolai-block"><span class="inline-wrap">LeetCode 中的练习题目</span></h3><ol class="wolai-block"><li id="kp5GNm6P4ho6rU4ZTCkaGC"><div class="marker"></div><span class="inline-wrap"><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/"><span>LeetCode 94: Binary Tree Inorder Traversal</span></a></span></li><li id="4f9PYeSWfbLjQiYaXiAUyY"><div class="marker"></div><span class="inline-wrap"><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/"><span>LeetCode 102: Binary Tree Level Order Traversal</span></a></span></li><li id="sJsa4brzeo8SHKBtFqMGYa"><div class="marker"></div><span class="inline-wrap"><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/"><span>LeetCode 236: Lowest Common Ancestor of a Binary Tree</span></a></span></li></ol></article><footer></footer></body></html>